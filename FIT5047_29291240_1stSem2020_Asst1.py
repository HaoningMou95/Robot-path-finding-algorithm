import argparse as apimport reimport numpyimport platform######## RUNNING THE CODE #####################################################   You can run this code from terminal by executing the following command#   python planpath.py <INPUT/input#.txt> <OUTPUT/output#.txt> <flag>#   for example: python planpath.py INPUT/input2.txt OUTPUT/output2.txt 0#   NOTE: THIS IS JUST ONE EXAMPLE INPUT DATA################################################################################################# YOUR CODE GOES HERE ########################################import numpyclass Node:    def __init__(self, x, y, parent=None):        self.parent = parent        self.x = x        self.y = y        self.g = 0        self.h = 0        self.f = 0        self.route = ''        self.id = ''    def __eq__(self, other):        return self.x == other.x and self.y == other.yclass A_star:    def __init__(self):        self.opened = []        self.closed = []        self.path = []    def getMinNode(self):        '''        get the min cost from the opened list        :return: the min cost node        '''        if len(self.opened) > 0:            nodeTemp = self.opened[0]            for node in self.opened:                if node.g + node.h < nodeTemp.g + nodeTemp.h:                    nodeTemp = node            return nodeTemp    def isInOpenList(self, other):        for exist_node in self.opened:            if other == exist_node:                return True        return False    def isInCloseList(self, other):        for exist_node in self.closed:            if other == exist_node:                return True        return False    def a_star(self, map,flag):        indictor = 0        sizeTemp = map.pop(0)        # sizeTemp += file.pop(0)        size = int(sizeTemp)        map = numpy.array(map).reshape(size, size)        start = [0, 0]        end = [0, 0]        for i in range(size):            for j in range(size):                if map[i, j] == 'S':                    start = [i, j]                if map[i, j] == 'G':                    end = [i, j]        id = 0        expand_order = 0        start_node = Node(start[0], start[1], None)        start_node.h = start_node.g = start_node.f = 0        goal_node = Node(end[0], end[1], None)        goal_node.h = goal_node.g = goal_node.f = 0        direction = {(-1, -1):"LU", (-1, 0):"U", (-1, 1):"RU",   #direction definiation                     ( 0, -1):"L",               ( 0, 1):"R",                     ( 1, -1):"LD", (1,0):"D",   ( 1, 1):"RD", }        start_node.id = 'N0'        start_node.route = 'S'        self.opened.append(start_node)#append the start node into open list        while len(self.opened) > 0:#start search            current_node = self.getMinNode() #get the smalleset g value node in the open list            del self.opened[self.opened.index(current_node)] #delete it from open list            self.closed.append(current_node) #add it into the close list            # print('before if',current_node.x, current_node.y)            if current_node == goal_node: #found the goal node                # print(current_node)                current = current_node                end_path = current_node.route   #get the direction movement                while current is not None: #find the path alone it's parents                    self.path.append([current.x, current.y])                    current = current.parent                # return self.path[::-1],  end_path+'-G'                # path_emp = "".join(self.path[::-1])                longStr = ''                # for step in self.path[::-1]:                #     mapTemp = map                #     mapTemp[step[0],step[1]] = '*'                #     longStr = "".join(mapTemp)                #                # return longStr                return end_path+'G' #return the path            children = []            for dir in direction.keys(): #get the move directions                node_position = [current_node.x + dir[0], current_node.y + dir[1]]                if node_position[0] > (size - 1) or node_position[0] < 0 \                   or node_position[1] > (size - 1) or node_position[1] < 0:                    continue                #to make detect is there any mountain near the current node. If yes, dont move to there                if map[node_position[0], node_position[1]] == "X" or map[[current_node.x],[node_position[1]]] == 'X' \                        or map[[node_position[0]],[current_node.y]] == 'X':                    continue                new_node = Node(node_position[0], node_position[1], current_node) #add avaliable node into the children list                new_node.route = new_node.parent.route + '-' + direction[dir]                if not self.isInOpenList(new_node): #check if the node is already in the lsit                    children.append(new_node)            #explore the neibours            for child in children:                flg = True                for closed_child in self.closed: #elinamite the child if it's already in close list                    if child == closed_child:                        child.x, child.y = -1, -1                        flg = False                        break                if flg: #indicate wether the child have been added or not                    if (abs(child.x - current_node.x) + abs(child.y - current_node.y)) > 1:                        child.g = current_node.g + 1                    else:                        child.g = current_node.g + 2                    if child.id == '':                        id += 1                        child.id = 'N' + str(id)                    # child.h = abs(child.x - goal_node.x) if abs(child.x - goal_node.x) > abs(child.y - goal_node.y) else abs(child.y - goal_node.y) #25 24 cost                    child.h = round((((child.x - goal_node.x) ** 2 + (child.y - goal_node.y) ** 2) / 2 ** 0.5), 2) #h function                    child.f = round((child.g + child.h), 2)                    self.opened.append(child) # add nebour into  oplist            expand_order += 1            print('current node')            print(current_node.id + ': ' + str(expand_order), current_node.route, str(current_node.g) + ' '                  + str(current_node.h) + ' ' + str(current_node.f))            if indictor < flag:                print('\nchildren')                for node in children:                    if node.x == -1 and node.y == -1:                        continue                    print(node.id+':', node.route,' ', end='')                print('\n\nopen list')                for node in self.opened:                    print(node.id+':', node.route, str(node.g)+' '+str(node.h)+' '+str(node.f))                print('\n\nclose list')                for node in self.closed:                    print(node.id+':', node.route, str(node.g) + ' ' + str(node.h) + ' ' + str(node.f))                print()                indictor += 1        if len(self.opened) == 0:            return 'No path', 'No path'def graphsearch(map, flag):    solution = "S-R-RD-D-D-LD-G"    a = A_star()    solution = a.a_star(map, flag)    return solutiondef read_from_file(file_name):    # You can change the file reading function to suit the way    # you want to parse the file    map = [ch for ch in open(file_name).read() if ch != '\n' if ch != ' ']    # sizeTemp = file.pop(0)    # # sizeTemp += file.pop(0)    #    # size = int(sizeTemp)    # map = numpy.array(file).reshape(size, size)    # start = [0, 0]    # end = [0, 0]    #    # for i in range(size):    #     for j in range(size):    #         if map[i, j] == 'S':    #             start = [i, j]    #         if map[i, j] == 'G':    #             end = [i, j]    return map########################################################################################## DO NOT CHANGE ANYTHING BELOW #####################################################################################################################def write_to_file(file_name, solution):    file_handle = open(file_name, 'w')    file_handle.write(solution)def main():    # create a parser object    parser = ap.ArgumentParser()    # specify what arguments will be coming from the terminal/commandline    parser.add_argument("input_file_name", help="specifies the name of the input file", type=str)    parser.add_argument("output_file_name", help="specifies the name of the output file", type=str)    parser.add_argument("flag", help="specifies the number of steps that should be printed", type=int)    # parser.add_argument("procedure_name", help="specifies the type of algorithm to be applied, can be D, A", type=str)    # get all the arguments    arguments = parser.parse_args()############################################################################### these print statements are here to check if the arguments are correct.#    print("The input_file_name is " + arguments.input_file_name)#    print("The output_file_name is " + arguments.output_file_name)#    print("The flag is " + str(arguments.flag))#    print("The procedure_name is " + arguments.procedure_name)##############################################################################    # Extract the required arguments    operating_system = platform.system()    if operating_system == "Windows":        input_file_name = arguments.input_file_name        input_tokens = input_file_name.split("\\")        if not re.match(r"(INPUT\\input)(\d)(.txt)", input_file_name):            print("Error: input path should be of the format INPUT\input#.txt")            return -1        output_file_name = arguments.output_file_name        output_tokens = output_file_name.split("\\")        if not re.match(r"(OUTPUT\\output)(\d)(.txt)", output_file_name):            print("Error: output path should be of the format OUTPUT\output#.txt")            return -1    else:        input_file_name = arguments.input_file_name        input_tokens = input_file_name.split("/")        if not re.match(r"(INPUT/input)(\d)(.txt)", input_file_name):            print("Error: input path should be of the format INPUT/input#.txt")            return -1        output_file_name = arguments.output_file_name        output_tokens = output_file_name.split("/")        if not re.match(r"(OUTPUT/output)(\d)(.txt)", output_file_name):            print("Error: output path should be of the format OUTPUT/output#.txt")            return -1    flag = arguments.flag    # procedure_name = arguments.procedure_name    try:        map = read_from_file(input_file_name) # get the map    except FileNotFoundError:        print("input file is not present")        return -1    # print(map)        solution_string = "" # contains solution    solution_string = graphsearch(map, flag)    write_flag = 1        # call function write to file only in case we have a solution    if write_flag == 1:        write_to_file(output_file_name, solution_string)if __name__ == "__main__":    main()